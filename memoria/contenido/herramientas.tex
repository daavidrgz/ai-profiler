\chapter{Herramientas, técnicas y lenguajes}
\label{chap:herramientas}

\lettrine{U}na vez abordada la tarea de investigación del estado del arte del perfilado de autor y de la selección
de los algoritmos que formarán una parte fundamental de la aplicación, nos centraremos
en el desarrollo de la misma.
Así, a largo de este capítulo, se describirán las herramientas utilizadas en todo el proceso y se expondrán las
razones de su uso. A su vez, para una mejor estructuración, se dividirán en cuatro grupos diferentes:
herramientas del \textit{backend}, \textit{frontend}, algoritmos de perfilado y soporte.

\section{\textit{Backend}}
\label{sec:herramientas_backend}

Ya que para el \textit{backend} no se necesitaba nada excesivamente complejo, se decidió utilizar el lenguaje de programación Python \cite{python} junto
con FastAPI \cite{fastapi}, un \textit{framework} el cual permite crear APIs (del inglés, \textit{Application Programming Interface})
REST (del inglés, \textit{Representational State Transfer}) de forma sencilla. La decisión de utilizar Python viene
condicionada por el hecho de que los algoritmos de perfilado de autor utilizados, así como también la mayor parte de los algoritmos de aprendizaje automático
y procesamiento de lenguaje natural,
están ya programados en Python, lo que evitó crear nuevos \textit{endpoints}, \textit{sockets} o \textit{bindings} para la ejecución de dichos algoritmos.
Destacar también que el desarrollo ágil en Python favorecía mucho al trabajo debido a su tipado dinámico, a su ejecución interpretada y a su sintaxis simple.

\bigskip
En cuanto a la persistencia de los datos, se optó por MongoDB \cite{mongodb}, una base de datos NoSQL (del inglés, \textit{Not Only SQL}) que permite almacenar
datos en formato JSON (del inglés, \textit{JavaScript Object Notation}). La decisión de utilizar una base de datos NoSQL sobre otras opciones como puede ser
PostgreSQL \cite{postgresql} o MySQL \cite{mysql}, se debe a dos factores principales. Uno de ellos es la fácil implementación de MongoDB en Python
haciendo uso de la librería PyMongo \cite{pymongo}, dado que permite realizar operaciones sobre las colecciones de forma muy intuitiva.
El otro factor tiene que ver con la extensibilidad de la aplicación a largo plazo, y es que, frente a la creación de nuevos
campos o relaciones, MongoDB permitiría una integración simple gracias a la flexibilidad que ofrece sobre los esquemas de datos, algo imposible
si se emplease una base de datos relacional.

\section{\textit{Frontend}}
\label{sec:herramientas_frontend}

En cuanto al \textit{frontend}, se decidió utilizar NextJS \cite{nextjs} como herramienta para el desarrollo de la interfaz de usuario, dado que ya
se contaba con bastante experiencia previa en su uso. NextJS es un \textit{framework} basado en React \cite{react}, es decir, en la construcción de interfaces dinámicas e interactivas mediante la composición
de elementos que pueden tener estado. Además, esta herramienta implementa varias mejoras sobre React como por ejemplo el \textit{server-side rendering}, algo que ayuda en gran medida
al SEO (del inglés, \textit{Search Engine Optimizations}), esto es, a que los motores de búsqueda como \textit{Google} puedan indexar mejor la página y, por tanto, que esta aparezca en una posición superior en los resultados de búsqueda.
Además, también cuenta con optimizaciones para la carga y el renderizado de imágenes o fuentes, entre otras.

\bigskip
Todo ello se desarrolló utilizando TypeScript \cite{typescript}, un lenguaje de programación que añade tipado estático a JavaScript
y que está ganando mucha popularidad con respecto a la mantenibilidad, compresión y escalabilidad que proporciona a los proyectos en los que se usa (Stack Overflow, 2023) \cite{stackoverflow2023}.
A mayores, para garantizar la consistencia de todas las entidades, y más en específico de los DTOs (del inglés, \textit{Data Transfer Object}), se utilizó Zod \cite{zod}, una librería que permite
definir esquemas de validación de datos, incluyendo el tipo específico que debe tener cada campo.

\bigskip
En cuanto el estilado de la página, se optó por emplear SASS (del inglés, \textit{Syntactically Awesome Style Sheets}) \cite{sass}, un preprocesador de CSS (del inglés, \textit{Cascading Style Sheets}) que añade
funcionalidades extra como son el uso de variables, bucles o anidamiento de clases. Además, dado que se estaba desarrollando
una aplicación innovadora, se buscó crear un estilo propio haciendo uso de CSS ``puro'', desmarcándose así de librerías que proporcionasen estilos predefinidos como Bootstrap \cite{bootstrap} o componentes ya implementados
como Material UI \cite{materialui} o Chakra UI \cite{chakraui}. Por otra parte, para la creación de gráficos, se utilizó la librería ChartJS \cite{chartjs}, una de las más conocidas
y con más soporte en la actualidad. Finalmente, para implementar las animaciones en la interfaz, se hizo uso, en conjunto con las transiciones nativas
de CSS, de Framer Motion \cite{framermotion}, una librería que permite crear animaciones de una mayor complejidad desde JavaScript.

\section{Algoritmos de perfilado}
\label{sec:herramientas_algoritmos}

A pesar de que los algoritmos de perfilado se ejecutan en el \textit{backend}, se ha decidido incluirlos en esta sección debido a que se trata de una parte
importante y característica del proyecto. Decir también que, en este caso, las herramientas utilizadas estaban condicionadas, lógicamente,
por aquellas empleadas en las implementaciones de los algoritmos seleccionados en la Sección \ref{sec:algoritmos_seleccionados}.

\bigskip
En cuanto a la parte nuclear del aprendizaje automático, se utilizó Scikit-Learn \cite{scikitlearn}, una librería de Python que proporciona una gran cantidad
de algoritmos pre-implementados, así como también herramientas para la extracción de características o la validación de modelos. Además, se hizo uso
de otras librerías como Tqdm \cite{tqdm}, la cual permite mostrar el progreso de entramiento o predicción de forma visual, Pickle \cite{pickle}, que permite
serializar objetos Python (en nuestro caso los modelos ya entrenados), o NumPy \cite{numpy}, una librería que proporciona estructuras de datos y herramientas para el cálculo científico.

\section{Soporte}
\label{sec:herramientas_soporte}

En lo que respecta a la gestión de tareas, debido a que nuestro ciclo de desarrollo era ágil, se utilizó Trello \cite{trello}, una herramienta que permite crear tableros con listas de tareas, las cuales pueden moverse
entre ellas según su estado: pendiente, en progreso o completada. En la misma línea, para efectuar las reuniones necesarias para la planificación de las tareas, se utilizó Microsoft Teams \cite{teams}, una plataforma
de comunicación que permite realizar videollamadas, compartir la pantalla o enviar archivos, entre otras funcionalidades.

\bigskip
Además, debido a la importancia de mantener un historial sobre los cambios realizados en el código, se optó por utilizar Git \cite{git} como herramienta de control de versiones junto a GitHub \cite{github}, una plataforma que permite
almacenar repositorios Git de forma remota, similar a otras como GitLab \cite{gitlab} o BitBucket \cite{bitbucket}.

\bigskip
En cuanto al entorno de desarrollo o IDE (del inglés, \textit{Integrated Development Environment}), se utilizó Visual Studio Code \cite{vscode}, un editor gratuito y de código semi-abierto desarrollado por Microsoft, el cual
brinda una gran flexibilidad para trabajar con cualquier lenguaje de programación gracias a sus extensiones. Esto hecho, posibilitó el desarrollo
del \textit{backend}, del \textit{frontend} e inluso de esta memoria en un mismo programa, simplificando la tarea de aprender las peculiaridades de
otros IDEs más específicos. Más en concreto, se utilizaron extensiones como Prettier \cite{prettier} o Black \cite{blackformatter}, las cuales permiten formatear el código de forma automática para JavaScript o Python, respectivamente;
ESLint \cite{eslint}, una herramienta que permite detectar errores en el código JavaScript/TypeScript; o GitLens \cite{gitlens}, una extensión que añade funcionalidades extra con respecto
al control de cambios.

\bigskip
En relación a la elaboración de los diagramas y los \textit{wireframes} que aparecen en este trabajo, se utilizó la herramienta de código abierto Draw.io \cite{drawio}, la cual permite crear todo tipo de diagramas
\textit{online} de forma gratuita, sin la necesidad de registrarse ni de instalar ningún programa.
Junto a esta herramienta, se utilizó también la librería pgfplots \cite{pgfplots} para la creación de las gráficas en el propio \LaTeX.

\bigskip
Finalmente, para facilitar la puesta en marcha de todas las partes que conforman el sistema y evitar instalar todas las dependencias de forma manual, se utilizó Docker \cite{docker},
una herramienta que permite crear contenedores, esto es, entornos de ejecución aislados que contienen todo lo necesario para que una aplicación funcione correctamente.
